#include <stdio.h> // I require the standard input out such as printf and scanf
#include <stdlib.h> // I require this for the rand function which is apparently held in this library
#include <stdlib.h> // within the srand function I am seeding a random number from the time 'time(NULL)'

void restart(int*, int*, int*, int*, char**);							// game - main holder of game variables
void userinfo(int*, int*, int*);										// human - user makes game options
char** allocateboard();													// game start - allocate heap memory
void printboard(int*, char**);											// both - print the board for every turn
void human(int*, int*, int*, int*, char**);								// human - human turn
void comp(int*, int*, int*, int*, char**);								// comp - computer turn
int checkentry(int, int, char**);										// both - ensure entry has not been taken already
int checkspace(int*, char**);											// both - ensure there is space on the board, if not, call draw
void check4(int*, int*, int*, int*, char**);							// both - check for win
int test4(char, char, char, char);										// both - test for 4 in a row boolean return
void check(int*, int*, int*, int*, char**);								// comp - check for 3 and 2 in a row
int test3(char, char, char, int, int*);									// comp - test for true 3
int test2(char, char, int, int*);										// comp - test for true 2
void placeh(int*, int*, int*, int*, char**, int, int, int);				// comp - place marker to block/ win horozontal
void placev(int*, int*, int*, int*, char**, int, int, int);				// comp - place marker to block/ win vertical
void placedr(int*, int*, int*, int*, char**, int, int, int);			// comp - place marker to block/ win diagonal down right
void placedl(int*, int*, int*, int*, char**, int, int, int);			// comp - place marker to block/ win diagonal down left
void endgo(int*, int*, int*, int*, char**, int, int);					// both - confirmed place for marker position, place marker
void deallocateboard(int*, char**);										// game finished, free heap
void win(int*, int*, int*, int*, char**);								// game won, end/ restart
void draw(int*, int*, int*, int*, char**);								// game draw, end/ restart

void main()
{
	int		size = 0, // value for size of grid will be stored here throughout
			marker = 1, // 1 = to place X, 2 = to place O. - value stored here throughout
			vs = 0, // 1 = H v H, 2 = H v C. Value stored here throughout
			turn = 0; // 1 = H, 2 = C. Value stored here throughout
	char	**grid; // this reason for this double pointer will become clear in the function allocateboard. It exists here so that it may be called from main to start the game.
	
	srand(time(NULL)); // the random numbers that I will be getting from here (for the computers turn) will be randomly generated by using the system time. The same numbers will be generated in any one second, but this only means that if the computer decides to choose a position already taken, then it will only be a matter of seconds before it chooses one that is not already taken. There is a trade off between time taken by computer and the computer taking the same moves each go.
	printf("\nWelcome to '4 in a row'!!\n\nThe objective of this game is to place 4 of your markers in a row either horizontally, vertically or diagonally. The first player to do so is the winner!!!\n\n");
	userinfo(&size, &vs, &turn);// save user inputs into the addresses of these values
	grid = allocateboard();	// save the double pointer returned by the func allocateboard
	printboard(&size, grid); // so that the user may see the board before either player/ computer plays, print it while it is empty (full of spaces --> ' ') The function requires the address of size and not the value itself so that the function can be called later from elsewhere from the function restart. The use of pointers here makes it possible to bypass main and thus not receiving all of the intial information for the user.
	if(turn == 1) // refer to the function userinfo for how turn = 1 means human first.
		human(&size, &marker, &turn, &vs, grid); // if turn = 1 then human goes first. All pointers so that function can be called later with values. Also, these values will change throughout the program lifecycle.
	if(turn == 2) // refer to userinfo
		comp(&size, &marker, &turn, &vs, grid); // if turn = 2 then computer goes first.
}

void restart(int* size, int* marker, int* turn, int* vs, char **grid) // after the initial game this function restarts it and uses the addresses (like all functions below) for the handling of information.
{
	int		i = 0, // just to reinitialise the grid to empty
			j = 0; // just to reinitialise the grid to empty
	
	for(i = 0 ; i < 9 ; i++)
		for(j = 0 ; j < 9 ; j++)
			grid[i][j] = ' '; // initialise the grid to spaces
	userinfo(size, vs, turn); // get user to reenter new game details
	printboard(size, grid); // print new empty board
	if(*turn == 1) // as before
		human(size, marker, turn, vs, grid);
	if(*turn == 2) // as before
		comp(size, marker, turn, vs, grid);
}

void userinfo(int* size, int* vs, int* turn)
{
	printf("Please enter the grid size between 4 and 9.... eg. for a 5 x 5 grid, please enter '5'.\n");
	scanf(" %d", size); // send size details to the address of size (size here is the address of size in func main)
	while( (*size < 4) || (*size > 9) ){ // only allow user to enter size of board beween 4 and 9
		printf("That was an incorrect entry. Please enter between 4 and 9...\n");
		scanf(" %d", size);
	}
	printf("To play human vs human enter '1', for human vs computer enter '2'...\n");
	scanf(" %d", vs); // this value will determine whether the cycle passes to the computer or not

	while( (*vs != 1) && (*vs != 2) ){ // only the entries 1 and 2 are acceptable
		printf("That was an incorrect entry. Please enter '1' for human vs human, or '2' for human vs computer\n");
	    scanf(" %d", vs);
	}
	if(*vs == 1) // if the value help at the address of vs (which is also where the value of vs (in main) is held) then human vs human is on and the turn will be 1 (turn 1 will always be the humans turn)
		*turn = 1;
	if(*vs == 2){ // if computer is to play then allow user to decide who is to play first.
		printf("Human vs Computer\nIf you would like to play first, enter '1'.\nIf you would like to play second, enter '2'.\n\n");
        scanf("%d", turn); // if the computer is to play then user enters turn = 1 to make human play first, or 2 to make computer to play first.
		while( (*turn != 1) && (*turn != 2) ){ // only allow 1 or 2 to be entered
			printf("That was an incorrect entry. Please enter '1' to play first, or '2' for to play second\n");
			scanf("%d", turn);
		}
	}
}

char** allocateboard()
{
	int		i, // counter for matrix
			j; //  counter for matrix
	char	**g; // this pointer will point to a pointer which will be returned as the return in the form of a set of arrays attached to one other array. Graphically would look like branches of equal length coming off a spine of also equal length

	g = (char**) malloc( 9 * sizeof(char*) ); // first I create a bank of memory with the type, char*. This 'array of pointers' has an intial location which is a pointer to 'a bunch of pointers', therefore the intial type of this memory location is 'char**'. I have asked for 9 x char*'s as the size of the board will only be up to 9.
	if(g == NULL) // test for memory allocation failure
		printf("ERROR with 1st MALLOC\n"); // allow user to be notified of memory allocation failure
	
	for(i = 0 ; i < 9 ; i++){ // counter for each pointer in the previously allocated memory.
		g[i] = (char*) malloc( 9 * sizeof(char) ); // for each pointer allocated already, another 9 pieces of memory is required to form the 'columns' of the board/ grid. The initial piece of memory type is a pointer to this section of memory and therefore is char*. The actual pieces of memory will hold the char's X or O therefore are of type char.
		if(g[i] == NULL) // allocation test
			printf("ERROR with grid[%d] MALLOC\n", i); // let user know which allocation of memory failed
	}
	for(i = 0 ; i < 9 ; i++) // initialise gris to ' '.
		for(j = 0 ; j < 9 ; j++) // initialise gris to ' '.
			g[i][j] = ' '; // NOTE: g[i] refers to the location along the first memory allocation, which are all pointers (char*). g[i][j] refers firstly to the first memory allocation which is a pointer (char*) and then to --> [j], which is the char that is stored in that memory allocation...
	return g; // return the double pointer g so that this 'table/ grid/ matrix' can be used later.
}

void printboard(int* size, char **grid) // this function is a complicated set of repition where the first row  and last row on the board to be printed are different than the rest. Each row on the board has 3 graphical rows printed, except the first, which has 1.
{
	int i = 0,
		j = 0;

	system("cls"); // call the window to clear the screen for user friendliness.
	printf("\n\n");
	for(j = 0 ; j < *size ; j++){ // The first row comprises of 
            if(j == 0) // this exists to fill the space of where the row number would be on later rows (this is not a grid row, just a column reference row).
                 printf("  "); // spaces carefully workled out.
            else
                 printf(" %d  ", j); // print the column number for user reference
        }
        printf(" %d  \n", j); // print out the last column number and start newline for the main board
////////////////////////////////////////// the section above this write the column numbers. Below is main board
	for(i = 0 ; i < (*size - 1) ; i++){
		for(j = 0 ; j < (*size - 1) ; j++){
                if(j == 0)
                    printf("     |");
                else
                    printf("   |");
            }
		printf("   \n");
		
		for(j = 0 ; j < (*size - 1) ; j++){
                if(j == 0)
                    printf("%d  %c |", (i + 1), grid[i][j]);
                else
                    printf(" %c |", grid[i][j]);
            }        
		printf(" %c \n", grid[i][j]);
		
		for(j = 0 ; j < (*size - 1) ; j++){
                if(j == 0)
                    printf("  ___|");
                else
                    printf("___|");
            }
		printf("___\n");
	}
	for(j = 0 ; j < (*size - 1) ; j++){
            if(j == 0)
                printf("     |");
            else
                printf("   |");
        }
	printf("   \n");
	
	for(j = 0 ; j < (*size - 1) ; j++){
            if(j == 0)
                 printf("%d  %c |", (i + 1), grid[i][j]);
            else
                 printf(" %c |", grid[i][j]);
        }
	printf(" %c \n", grid[i][j]);
	
	for(j = 0 ; j < (*size - 1) ; j++){
            if(j == 0)
                 printf("     |");
            else
                 printf("   |");
        }
	printf("   \n\n");
}

void human(int* size, int* marker, int* turn, int* vs, char** grid)
{
	int row = 0,
		col = 0;

	if(checkspace(size, grid) == 0) // if checkspace = 0 then there are no spaces left on the board as a draw is called.
		draw(size, marker, turn, vs, grid); // draw function called in this case
    	if(*marker == 1) // when marker = 1, it is the turn of X, regardless who X is, human, computer or second human. Value switches from 1 to 2 after each turn has been had regardless of who took it. Marker will always = 1 on the first turn regardless who takes it.
		printf("Player X, it is your turn\n");
	if(*marker == 2)
		printf("Player O, it is your turn\n");
	
	printf("Enter the row number for your marker (from 1 to %d)\n", *size); // The user is to type in a row number between 1 and the maximum number of rows which was determined by the value held at the address of size, entered by the user.
	scanf("%d", &row); // save this value at the address of row.
	while( ((row < 1) || (row > *size)) ){ // only allow the user to enter the min value of 1, and max value determined by size.
		printf("You entry was outside limits. Please enter a valid row number (from 1 to %d)\n", *size);
		scanf("%d", &row);
	}
	printf("Enter the column number for your marker (from 1 to %d)\n", *size); // do the same for column as for row (note that it is a square grid).
	scanf("%d", &col);
	while( ((col < 1) || (col > *size)) ){
		printf("You entry was outside limits. Please enter a valid column number (from 1 to %d)\n", *size);
		scanf("%d", &col);
	}
	row = row - 1; // so to fit in with the tradition that the row and col when put into g[row][col], that row 1, column 1 should refer to g[0][0] in memory
	col = col - 1; // as before.

	while(checkentry(row, col, grid)){ // this function tests for already entered markers in the entered position. If the func returns true, then that position is previously taken so the user is asked to re-enter a new position.
		printf("That move has been taken. Please enter another position...\n\nEnter the row number for your marker (from 1 to %d)\n", *size);
		scanf("%d", &row);
		printf("Enter the column number for your marker (from 1 to %d)\n", *size);
		scanf("%d", &col);
		while( ((row < 1) || (row > *size)) ){ // only allow the user to enter the min value of 1, and max value determined by size.
			printf("You entry was outside limits. Please enter a valid row number (from 1 to %d)\n", *size);
			scanf("%d", &row);
		}
		while( ((col < 1) || (col > *size)) ){
			printf("You entry was outside limits. Please enter a valid column number (from 1 to %d)\n", *size);
			scanf("%d", &col);
		}
		row = row - 1;
		col = col - 1;
	}
	endgo(size, marker, turn, vs, grid, row, col); // once the fact that a draw has not taken place and that a position on the board has not been entered again, the row and col entered by the user is passed to the endgo function which works the algoritm to actually enter the data into the grid and pass the move onto the next important step.
}

void comp(int* size, int* marker, int* turn, int* vs, char** grid)
{
	int row,
		col;
		
	if(checkspace(size, grid) == 0) // as in human, check for draw.
		draw(size, marker, turn, vs, grid);
	check(size, marker, turn, vs, grid); // the computer must place a marker, but the position of its marker must be prioritised. the check function goes through that priority. If these priority marker placements are not met, then a random position is selected below.
	
	row = rand()%(*size); // random number seeded from system time (in main)
	col = rand()%(*size); // as before for column
	while(checkentry(row, col, grid)){ // check to ensure that the random number hasnt selected a previously selected position.
		row = rand()%(*size);
		col = rand()%(*size);
	}
	endgo(size, marker, turn, vs, grid, row, col); // once a correct position from the random functino has been selected, endgo as for human.
}

int checkentry(int row, int col, char** grid)
{
	return (grid[row][col] != ' '); // function tests true (1) if the selected position is not a space.
}

int checkspace(int* size, char** grid)
{
	int i, // counter to pass through rows
		j, // counter to pass through columns
		spaces = 0; // counts the number of spaces. Starts at 0 as this is also going to be returned

	for(i = 0; i < *size; i++)
		for(j = 0; j < *size; j++){
			if(grid[i][j] == ' ')
				spaces = spaces + 1; // for every space that is counted, 'spaces' increases in value by 1.
		}
		return spaces; // if there are no spaces on the board then 0 is returned and a draw is called. Otherwise is returns a non-zero int.
}

void check4(int* size, int* marker, int* turn, int* vs, char** grid) // tests for win (after each turn has been made.
{
	int i = 0,
		j = 0;

	for(i = 0 ; i < *size ; i++) // for all possible reaches that do not disappear off the board takes into account where testing for further grid positions are going to reach to.
		for(j = 0 ; j < (*size - 3) ; j++)
			if( test4(grid[i][j], grid[i][j+1], grid[i][j+2], grid[i][j+3]) ){ // test for horizontal win
				printf("'%c' is the winner!\n", grid[i][j]); // if win is detected, state that the marker at the tested position has won.
				win(size, marker, turn, vs, grid); // and then goto win function.
			}
	for(i = 0 ; i < (*size - 3) ; i++)// for all possible reaches that do not disappear off the board takes into account where testing for further grid positions are going to reach to.
		for(j = 0 ; j < *size ; j++)
			if( test4(grid[i][j], grid[i+1][j], grid[i+2][j], grid[i+3][j]) ){// test for vertical win
				printf("'%c' is the winner!\n", grid[i][j]);// if win, state.
				win(size, marker, turn, vs, grid); // goto win func
			}
	for(i = 0 ; i < (*size - 3) ; i++)// as before
		for(j = 0 ; j < (*size - 3) ; j++){
			if( test4(grid[i][j], grid[i+1][j+1], grid[i+2][i+2], grid[i+3][i+3]) ){// test for diagonal right down win
				printf("'%c' is the winner!\n", grid[i][j]);
				win(size, marker, turn, vs, grid);
			}
			if( test4(grid[i][j+3], grid[i+1][j+2], grid[i+2][j+1], grid[i+3][j]) ){// test for diagonal right up win
				printf("'%c' is the winner!\n", grid[i][j]);
				win(size, marker, turn, vs, grid);
			}
		}
	if((*vs == 2) && (*turn == 2)) // if vs = 2 then the computer must be being played against. If turn = 2 also, then it must be the computers turn
		comp(size, marker, turn, vs, grid); // call computer
	else // if any other combination is true, then it is the human turn
		human(size, marker, turn, vs, grid); // call human
}

int test4(char a, char b, char c, char d)
{
	return ( (a == b) && (b == c) && (c == d) && (d != ' ') );//  the test function for the win. Tests if the inputted co-orinates match and does not concern itself where those grids actually are. That is the job of the check4 function.
}

void check(int* size, int* marker, int* turn, int* vs, char** grid)
{
	int i, // row counter
		j, // column counter
		inarow, // this allows this one function to test for both 3 in a row and 2 in a row as I require it to do so.
		winblock; // this allows me to determine whether the computer will priorise an aggressive move or a defensive move.

	for(inarow = 3; inarow > 1; inarow--){ // first i test for 3 in a row then 2.
		for(winblock = 0; winblock <2; winblock++){ // First test for aggression, so computer places marker for personal gain (ie. when 3 in a row tested true, computer goes for win)
			for(i = 0 ; i < *size ; i++)
				for(j = 0 ; j < (*size - (inarow - 1)) ; j++){ // 3 days of configuring, I am not writing down it all out (ive got the paperwork with all the working out on it if you want it!!!!!!!)
					if(inarow == 3){ // for when testing for a win
						if( test3(grid[i][j], grid[i][j+1], grid[i][j+2], winblock, marker) )// use this test for a horizontal 3 in a row
							placeh(size, marker, turn, vs, grid, i, j, inarow); // if true, win/ block win
					}
					if(inarow == 2){ // when testing for a set up win attempt
						if( test2(grid[i][j], grid[i][j+1], winblock, marker) ) // test for horizontal win set up
							placeh(size, marker, turn, vs, grid, i, j, inarow); // block/ continue own set up
					}
				}
			for(i = 0 ; i < (*size - (inarow - 1)) ; i++)
				for(j = 0 ; j < *size ; j++){
					if(inarow == 3){// as before for...
						if( test3(grid[i][j], grid[i+1][j], grid[i+2][j], winblock, marker) )// 3 in a row - for vertical 3 in a row
							placev(size, marker, turn, vs, grid, i, j, inarow);
					}
					if(inarow == 2){ // for 2 in a row
						if( test2(grid[i][j], grid[i+1][j], winblock, marker) ) // 2 in a row test - for vertical 2 in a row
								placev(size, marker, turn, vs, grid, i, j, inarow);
					}
				}
			for(i = 0 ; i < (*size - (inarow - 1)) ; i++) 
				for(j = 0 ; j < (*size - (inarow - 1)) ; j++) {
					if(inarow == 3){
						if( test3(grid[i][j], grid[i+1][j+1], grid[i+2][i+2], winblock, marker) ){//grid testing for diagonal right
							if((i == 0) && (j == (*size - 3))) // if the grid happens to be situated in the top right corner, then a placement is not possible so ignore and continue looking for next 3 in a row, with...
								continue; // this operative
							if((i == (*size - 3) && (j == 0))) // same for bottom left corner.
								continue;
							placedr(size, marker, turn, vs, grid, i, j, inarow); // when found and they are not in 2 abov corners, then place marker (if possible).
						}
					}
					if(inarow == 2){
						if( test2(grid[i][j], grid[i+1][j+1], winblock, marker) ){ //testing for down right but for 2 in a row
							if((i == 0) && (j == (*size - 2)))
								continue;
							if((i == (*size - 2) && (j == 0))) // all same but for 2 in a row instead
								continue;
							placedr(size, marker, turn, vs, grid, i, j, inarow);
						}
					}
				}
			for(i = 0 ; i < (*size - (inarow - 1)) ; i++)
				for(j = 0 ; j < (*size - (inarow - 1)) ; j++){
					if(inarow == 3){
						if( test3(grid[i][j + 2], grid[i + 1][j + 1], grid[i + 2][j], winblock, marker) ){// grid testing for diagnoally down and to the left
							if((i == 0) && (j == 0)) // grid happend to be the top left then placement is not possible, ignore with...
								continue; // as before
							if((i == (*size - 3)) && (j == (*size - 3))) // or bottom right
								continue;
							placedl(size, marker, turn, vs, grid, i, j, inarow); // if not these tow cornoers, then place marker (if possible)
						}
					}
					if(inarow == 2){ // same for 2 in a row
						if( test2(grid[i][j + 1], grid[i + 1][j], winblock, marker) ){// grid test for down and to left
							if((i == 0) && (j == 0))
								continue;
							if((i == (*size - 2)) && (j == (*size - 2)))
								continue;
							placedl(size, marker, turn, vs, grid, i, j, inarow);
						}
					}
				}
		}	
	}
}

int test3(char a, char b, char c, int winblock, int* marker)
{
	if(winblock == 0){// if aggression is selected ('0') then...
		if(*marker == 1) // if computer is mkr = 1 ('X's), then
			return ( (a == b) && (b == c) && (c == 'X') ); // test for 'X's.
		else // if computer is mkr = 2 ('O's), then
			return ( (a == b) && (b == c) && (c == 'O') ); // test for 'O's.
	}
	if(winblock == 1){ // if testing for defensive action then...
		if(*marker == 1) // if computer is mkr = 1 ('X's), then
			return ( (a == b) && (b == c) && (c == 'O') ); // test for 'O's.
		else // if computer is mkr = 2 ('O's), then
			return ( (a == b) && (b == c) && (c == 'X') ); // test for 'X's.
	}
	else
		return printf("Program error, please return to developer");
}

int test2(char a, char b, int winblock, int* marker) // same concept as test3 function above, but for 2 in a row instead.
{
	if(winblock == 0){
		if(*marker == 1)
			return ( (a == b) && (b == 'X') );
		else
			return ( (a == b) && (b == 'O') );
	}
	if(winblock == 1){
		if(*marker == 1)
			return ( (a == b) && (b == 'O') );
		else
			return ( (a == b) && (b == 'X') );
	}
	return printf("Program error, please return to developer");
}

// these following 4 place functions have all the possible situations marked and seperated so that the placement of a marker does not fall outside of the grid limits.

void placeh(int* size, int* marker, int* turn, int* vs, char** grid, int i, int j, int inarow) // dedicted to placing markers along horizontal lines of markers
{
	int row,
		col;

	if(j == (*size - inarow)) // if the column = the 'inarow' value (ie, 2 or 3) from the right of the grid, then there is no space on the right of the grid to place a marker...
		if(grid[i][j-1] == ' '){ // so the test for this position is only to the left of the row of 2 or 2 markers found.
			row = i; // if there is a space there, then mark row and column with the value of the position that the space currently is...
			col = j - 1;
			endgo(size, marker, turn, vs, grid, row, col); // and endgo, which will fill that space with the marker and thus the highest priority space would have been filled.
		}
	if(j == 0) // the same is done for the rest of the place functions.
		if(grid[i][j + inarow] == ' '){
			row = i;
			col = j + inarow;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (j != 0) && (j != (*size - inarow)) ){
		if(grid[i][j - 1] == ' '){
			row = i;
			col = j - 1;
			endgo(size, marker, turn, vs, grid, row, col);
		}
		if(grid[i][j + inarow] == ' '){
			row = i;
			col = j + inarow;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	}
}

void placev(int* size, int* marker, int* turn, int* vs, char** grid, int i, int j, int inarow) // dedicted to placing markers along vertical lines of markers
{
	int row,
		col;

	if(i == (*size - inarow))
		if(grid[i-1][j] == ' '){
			row = i - 1;
			col = j;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if(i == 0)						
		if(grid[i+inarow][j] == ' '){
			row = i + inarow;
			col = j;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (i != 0) && (i != (*size - inarow)) ){
		if(grid[i-1][j] == ' '){
			row = i - 1;
			col = j;
			endgo(size, marker, turn, vs, grid, row, col);
		}
		if(grid[i + inarow][j] == ' '){
			row = i + inarow;
			col = j;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	}
}

void placedr(int* size, int* marker, int* turn, int* vs, char** grid, int i, int j, int inarow) // dedicted to placing markers along diagonal right and down lines of markers
{
	int row,
		col;

	if( (j == 0) && (i < (*size - inarow)) ) // left column		
		if(grid[i + inarow][j + inarow] == ' '){
			row = i + inarow;
			col = j + inarow;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (i == 0) && (j < (*size - inarow)) )// top row		
		if(grid[i + inarow][j + inarow] == ' '){
			row = i + inarow;
			col = j + inarow;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (j == (*size - inarow)) && (i > 0) )// right column
		if(grid[i - 1][j - 1] == ' '){
			row = i - 1;
			col = j - 1;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (j > 0) && (i == (*size - inarow)) )// bottom row
		if(grid[i - 1][j - 1] == ' '){
			row = i - 1;
			col = j - 1;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (j > 0) && (j < (*size - inarow)) && (i > 0) && (i < (*size - inarow)) ){ // unlike the horizontal and vertical place functions, the diagonal place functions require more restriction on placement due to being affected by the corners of the grid in different ways depending on the corner. The above 4 if tests essentially check against rules for each side that the row may fall against so that no placement is made outside of the grid. This if function checks for spaces either side of the found row if the row lies not against the edge of the grid, but in the center, so that either end of the row could legally have a marker placed.
		if(grid[i + inarow][j + inarow] == ' '){// thif if tests for space against one end of the foudn row...
			row = i + inarow;
			col = j + inarow;
			endgo(size, marker, turn, vs, grid, row, col);
		}
		if(grid[i - 1][j - 1] == ' '){ // and this if tests for a space against the other end. The same can be said for the next (diagonal) placement function.
			row = i - 1;
			col = j - 1;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	}
}

void placedl(int* size, int* marker, int* turn, int* vs, char** grid, int i, int j, int inarow) // dedicted to placing markers along diagonal down and left lines of markers
{
	int row,
		col;

	if( (j > 0) && (i == 0) )// top row
		if(grid[i + inarow][j - 1] == ' '){
			row = i + inarow;
			col = j - 1;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (j == (*size - inarow)) && (i < (*size - inarow)) )// right column
		if(grid[i + inarow][j - 1] == ' '){
			row = i + inarow;
			col = j - 1;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (j == 0) && (i > 0) )// left column
		if(grid[i - 1][j + inarow] == ' '){
			row = i - 1;
			col = j + inarow;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (j < (*size - inarow)) && (i == (*size - inarow))  )// bottom row
		if(grid[i - 1][j + inarow] == ' '){
			row = i - 1;
			col = j + inarow;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	if( (j > 0) && (j < (*size - inarow)) && (i > 0) && (i < (*size - inarow)) ){// internal find
		if(grid[i + inarow][j - 1] == ' '){//one end
			row = i + inarow;
			col = j - 1;
			endgo(size, marker, turn, vs, grid, row, col);
		}
		if(grid[i - 1][j + inarow] == ' '){// other end
			row = i - 1;
			col = j + inarow;
			endgo(size, marker, turn, vs, grid, row, col);
		}
	}
}

void endgo(int* size, int* marker, int* turn, int* vs, char** grid, int row, int col)
{
	if(*marker == 1){ // if the marker = 1 ie 'X', then...
		grid[row][col] = 'X'; // place an 'X' into the row/ col co-ordinate that has been passed.
		*marker = *marker + 1; // change the marker value so that now 'O' is the desired marker.
		if(*turn == 1) // If it was 1 player turn...
			*turn = *turn + 1; // make it so that it is 2 players turn.
		else
			*turn = *turn - 1; // otherwise make the value of turn (= 2), become = 1, and thus the 1st players turn.
		printboard(size, grid); // print the board with the new marker on it.
		check4(size, marker, turn, vs, grid); // test for a win.
	}
	else{ // do the exact same but for if the marker was 'O'.
		grid[row][col] = 'O';
		*marker = *marker - 1;
		if(*turn == 1)
			*turn = *turn + 1;
		else
			*turn = *turn - 1;
		printboard(size, grid);
		check4(size, marker, turn, vs, grid);
	}
}

void deallocateboard(int* size, char** grid)
{
	int i; // counter required to free the char* pointers from the char** pointer array

	for(i = 0; i < 9; i++)
		free(grid[i]);// go though each char* on the char** array and free the memory.
	free(grid); // free the char** array.
	exit(EXIT_SUCCESS); // exit the game/ program.
}

void win(int* size, int* marker, int* turn, int* vs, char** grid)
{
	int q = 0;// variable to state whether the user would like to quit or not.

	printf("The game has been won. Would you like to start another game?\n\nEnter '1' to start another game, . To quit the game, enter '2'\n");
	scanf(" %d", &q);

	while( (q != 1) && (q != 2) ){ // only allow the user to select 1, or 2.
		printf("That was an incorrect entry. Please enter '1' to restart, and '2' to quit\n");
		scanf(" %d", &q);
	}
	if(q == 1)// if 1 is selected, then...
		restart(size, marker, turn, vs, grid);// call restart function
	if(q == 2) // if 2 is selected...
		deallocateboard(size, grid);// call deallocateboard function which will close the program.
}

void draw(int* size, int* marker, int* turn, int* vs, char** grid)// the same scenario for the draw function. restart or quit.
{
	int q = 0;

	printf("The game has been drawn. Would you like to start another game?\n\nTo start another game, enter '1'. To quit the game, enter '2'\n");
	scanf(" %d", &q);

	if(q == 1)
		restart(size, marker, turn, vs, grid);
	if(q == 2)
		deallocateboard(size, grid);
}
